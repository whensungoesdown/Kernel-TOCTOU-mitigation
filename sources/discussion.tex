
\section{Discussion}
\label{sec:ktoctou-discussion}


\textbf{\textit{Fuzzing.}} \autoref{sec:ktoctou-experiment} presents new method of fuzzing kernel TOCTOU vulnerabilities. Using hardware data breakpoints is also an option. Data breakpoint~\cite{krishnan2009hardware} a.k.a watchpoint is a debug feature that raises an exception when access setting memory locations.  DataCollider~\cite{krishnan2009hardware} use it to dynamically detects data races in kernel modules. Through static analysis,  DataCollider first decides the sampling set. Then it inserts code breakpoints, and when one code breakpoint fires, it uses a data breakpoint to trap the second access to detect conflicts. Although only several data breakpoints are available on each processor core, it is sufficient for hunting data race bugs.


Qemu~\cite{bellard2005qemu} with the dynamic binary translation (DBT)~\cite{ebcioglu2001dynamic} engine is also a good idea for fuzzing. The dynamic translation backend is called the tiny code generator (TCG)~\cite{bellard2005qemu}.  It converts binary code from the guest processor architecture to the host architecture. For example, it can take x86 guest code and turn it into an equivalent sequence of instructions natively executable on an ARM host, and it also can add instrumentation code~\cite{quynh2015unicorn}. QEMU with TCG is still slower than the hardware assistant virtualization, but it runs much faster than Bochs, making it capable of comprehensive fuzzing.

%There is another proposal. First load a driver which sets up VM environment, puts OS run as a virtual machine, just like our project does. Then transfer into kernel mode, invalidate all user-mode data pages, for example, clear the “Present” flag for all top-level user-mode data page table entries. In such way that all kernel-mode access to 00000000-7fffffff yield a page fault exception. The hypervisor intercepts the page fault and set TF (Single Step) flag and restore the faulting page to let the OS successfully execute the faulting instruction. After that it intercepts DB exception and set the page back to invalidate.  But the drawback is also obvious, both the kernel and user mode will trigger the page faults exceptions, so in a multi-thread process, once one thread call into kernel mode, other user mode thread may be interrupted too often due to their data accessing.




\textbf{\textit{Write Conflicts.}} As previously introduced in~\autoref{sec:ktoctou-design}, we solve the write conflicts by making the thread suspending inside the page fault handler until the kernel release the protected page. We also considered other options, such as a thread-level copy-on-write (COW) mechanism. The page table only splits when there is a write conflict so that the kernel and the user thread have their copy of the protected page. Then, the user thread can freely write it. The hypervisor maintains the newly forked page table and only use it when this particular thread is scheduled to run. We use similar techniques for monitoring the thread context switching~\cite{pan2017digtool}, other CR3 operation, some kernel data can be used to indicate the thread context switch. The process and thread are not aware of the double mapped virtual page. However, the issue lies in determining the time to merge the page tables and deciding which copy to take when there are data conflicts. Because even at the end of the current system call, many places on the page may change. Without the precise timing sequence information, it is hard to decide whether they would cause kernel-level TOCTOU issues or which copy has the latest data.



\textbf{\textit{Potential Attacks.}} When we discuss our mitigation with other security researchers, one researcher brought up a scenario as follows. Our mitigation protects a user page after the kernel access it. Although a user thread can not modify the page afterward, it can manipulate the kernel to do that. We acknowledged that this could be a possible attack because there are kernel vulnerabilities that give attacker kernel write capability. However, if the attacker already has such capabilities, the need to trigger another kernel-level TOCTOU vulnerability is questionable on a case-by-case basis.
