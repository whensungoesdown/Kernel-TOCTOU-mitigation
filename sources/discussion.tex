
\section{Discussion}
\label{sec:ktoctou-discussion}

\textbf{\textit{Fuzzing.}} We introduced a new method of fuzzing kernel TOCTOU vulnerabilities. Alternatively, using hardware data breakpoints is also an option. Data breakpoint~\cite{krishnan2009hardware} (also known as watchpoint) is a debug feature that raises an exception when accessing a targeted memory location.  DataCollider~\cite{krishnan2009hardware} is a lightweight technique for dynamically detecting data races in kernel modules. It randomly samples a small percentage of memory accesses as candidates for data-race detection using data breakpoints. However, only several data breakpoints are available on each processor core. Therefore, it can take only a few locations to monitor at a time.


Qemu~\cite{bellard2005qemu} with the dynamic binary translation (DBT)~\cite{ebcioglu2001dynamic} engine is also a good idea for fuzzing. QEMU's dynamic translation backend is called the tiny code generator (TCG)~\cite{bellard2005qemu}.  It converts binary code from the guest CPU architecture to the host architecture. For example, it can take x86 guest code and turn it into an equivalent sequence of instructions natively executable on an ARM host. It also can add instrumentation code~\cite{quynh2015unicorn}. QEMU with TCG will be much slower than the hardware assistant virtualization, but its performance is acceptable for a comprehensive fuzzing.

%There is another proposal. First load a driver which sets up VM environment, puts OS run as a virtual machine, just like our project does. Then transfer into kernel mode, invalidate all user-mode data pages, for example, clear the “Present” flag for all top-level user-mode data page table entries. In such way that all kernel-mode access to 00000000-7fffffff yield a page fault exception. The hypervisor intercepts the page fault and set TF (Single Step) flag and restore the faulting page to let the OS successfully execute the faulting instruction. After that it intercepts DB exception and set the page back to invalidate.  But the drawback is also obvious, both the kernel and user mode will trigger the page faults exceptions, so in a multi-thread process, once one thread call into kernel mode, other user mode thread may be interrupted too often due to their data accessing.



\textbf{\textit{Write Conflicts.}} As previously introduced in~\autoref{sec:ktoctou-design}, we solve the write conflicts by making the thread waiting inside the page fault handler. We also considered other options. For example, a thread-level copy-on-write (COW) mechanism maintained by the hypervisor. It only splits the page tables whenever the write conflict occurs. After that, the hypervisor dynamically changes page tables when the OS schedules on threads. Although there is no direct VM exit event that indicates a thread switching, since the OS needs to read/write data structures when doing this, by monitoring pages containing those data structures, it is possible to monitor it~\cite{pan2017digtool}. When a user-mode thread tries to write a protected page, our page fault handler will clone the page tables for the current process and assigns it to the writing thread.  Then allocate a new physical page to copy the protected page's content and use it to back up the virtual page in the new page table.  The issue with this proposal is determining the time to merge page tables. Moreover, it will hard to decide which copy to take when there are data conflicts.

Another idea is to emulate the instruction causing the write conflict in the page fault handler. We can record more detailed information about kernel accesses. To solve the write conflicts, we parse the faulting instruction and then update the memory accordingly. If the write overlaps the location that the kernel has read before, it is not easy to decide whether it is benign or dangerous because it depends on if the kernel is going to reread this location.



\textbf{\textit{Potential Attacks.}} When we discuss our mitigation with other security researchers, one researcher brought up a scenario as follows. Our mitigation protects a user-mode page after the kernel access. User-mode threads can not change it afterward because it is temporarily a kernel-mode page. However, some user-mode code could manipulate the kernel to change the page content for it.

We acknowledged that this could be a possible attack because there are kernel vulnerabilities that give attacker kernel write capability. However, once the attacker already has such capabilities, the need to trigger another kernel TOCTOU vulnerability is questionable on a case-by-case basis.
