\section{Limitations and Future Work}
\label{sec:limitation}


\begin{comment}
\subsection{Write Conflict}

As mentioned in~\autoref{sec:design}, our current implementation for solving write conflict is by delaying the writing thread. At first, we tried to solve it by implementing a more fine-grain COW(Copy On Write) which based on thread instead of process. Normal COW works in the following way.

Two or more processes share read-only pages, when data is written to these pages, the kernel intercepts the write attempt and allocates a new physical page, initialized with the original data. This is based


The other idea is that by implementing COW(Copy On Write) more fine-grain that based on threads, we can provide protection and writing consent at the same time. Traditional COW that based on processes is kept as is, such as module sharing won't be affected. Considering performance overhead, only page protection collision as discussed above happens, new page tables will be established and they splits from original ones. There will have one new page table entry which provides a new physical page mapping for the writing thread. Then the writing thread can write to the page without affecting the user buffer parameter which previously submitted to a system call. When the previous system call ends, it can trace the pages that being protected and other page tables that generated due to the collisions, merges two physical pages (update the original physical page with new modification) and eliminates the new generated page tables for the writing thread.

We think that comparing to the writing thread, the system call initiating thread is the first one who accessed the collision page. When the syscall ends, new data from the writing thread should be updated to the original page. If the updated part coincide with the buffer of the previous syscall parameter, then the data inconsistency should be correctly handled by operating system by default, because the change of data happens after a complete syscall.

Well known facts about paging on x86 architecture, for each thread, the root of page tables is stored in CR3, by which CPU can translate virtual-physical page mappings automatically in hardware. CR3 are updated by OS thread scheduling code during thread switching. Since we don't want to modify the target operating system, we can use hypervisor to monitoring thread switching events just like what we did for process context switching. There is no direct VM exit event that represent thread switching, but indirectly OS will access certain data structure when scheduling. By monitoring pages that contains certain system data structures, thread switching can be monitored~\cite{pan2017digtool}.
\end{comment}

\subsection{Further Optimizations}
Currently we reuse part of the functionality of Windows to flush TLB. Those Windows internal functions are not exported and changed prototype in newer versions. For further work, we plan to implement the mechanism of sending IPI.

Generally, when apply a low level mitigation to the whole system, in our case, one or more processes, there will be special cases. For example, as we mentioned earlier, we identify threads through process's CR3 and thread's TEB. But when create a new thread, right before it has been fully initialized, there are exceptions that current thread's TEB is zero. Now we trade such case specially, as we release those pages once there is any system call ends. We plan to find a more general solution to identify threads in order to avoid such special cases.  

\subsection{Leverage SMAP in Vulnerability Finding}
Monitoring memory accesses is a very useful technique in vulnerability finding. Vulnerability such as kernel TOCTOU's leaves obvious patterns of the way it access memory, for example, kernel-mode code accesses the same address of user-mode memory within a short period of time. The problem is how to efficiently monitor, since fetching memory data is the most common operation of a processor.

One way to do this is monitoring within a fully emulated virtual machine such as Bochs~\cite{lawton2003bochs}. It's easy to instrument both kernel and user mode code. Mateusz Jurczyk did an amazing job use Bochs to find kernel TOCTOU and memory disclosure vulnerabilities~\cite{jurczyk2013identifying}~\cite{bochspwnreloaded}. But one drawback about x86 emulation is the speed, running Windows within a full-blown x86-64 software emulator with additional instrumentation is extremely slow. It's difficult to perform an comprehensive test since lots of application crash because of slow operating system responses.

An alternative is to use data breakpoint(also called hardware breakpoint: trap when a processor reads or writes a particular memory location)~\cite{erickson2010effective}. The performance overhead is comparatively modest but the number of data breakpoints is limited (four on x86 architecture). Only a small number of program locations can be chosen for monitoring at a time.


%There is another proposal. First load a driver which sets up VM environment, puts OS run as a virtual machine, just like our project does. Then transfer into kernel mode, invalidate all user-mode data pages, for example, clear the “Present” flag for all top-level user-mode data page table entries. In such way that all kernel-mode access to 00000000-7fffffff yield a page fault exception. The hypervisor intercepts the page fault and set TF (Single Step) flag and restore the faulting page to let the OS successfully execute the faulting instruction. After that it intercepts DB exception and set the page back to invalidate.  But the drawback is also obvious, both the kernel and user mode will trigger the page faults exceptions, so in a multi-thread process, once one thread call into kernel mode, other user mode thread may be interrupted too often due to their data accessing.

We already repurposed SMAP for kernel TOCTOU mitigation, we want to further leverage it as a memory access monitor. Based on our testing, when a SMAP exception occurred, it's already to late to temporarily disable SAMP by executing instruction "STAC" which set AC flag in current EFLAGS register. The same exception will keep coming back. Therefore, We still have to add that page to kernel space, but with the setting of single step trap flag, we will set it back right at the next instruction. Therefore, all the user-mode memory accesses during a system call can be monitor. Plus, with our hypervisor, it can only applied on one process which dedicated on running complicated test cases. Compare to a fully emulated virtual machine, the overhead of our approach is modest.

During the implementation phase, we also find several bugs in win32k.sys module. Some of the code fetches user-mode data without a try catch block. These are potential denial of service vulnerabilities.