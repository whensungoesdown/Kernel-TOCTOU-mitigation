
\section{Limitations and Future Work}
\label{sec:limitation}

%\subsection{Leveraging SMAP in Vulnerability Finding}

\textbf{Leveraging SMAP in Vulnerability Finding  } Having a fast way to monitor memory accesses is very helpful when finding vulnerabilities such as kernel TOCTOU. Because this type of vulnerability has an obvious pattern. For example, the kernel reads a user address twice within one syscall. But as mentioned earlier, memory operations are too common to barely trigger any event. 

Existing methods including monitoring within a fully emulated virtual machine such as Bochs~\cite{lawton2003bochs}. It's easy to instrument both kernel and user code. Security researcher Mateusz Jurczyk did an amazing job using Bochs to find kernel TOCTOU and memory disclosure vulnerabilities~\cite{jurczyk2013identifying}~\cite{bochspwnreloaded}. But one drawback of x86 emulation is the performance, because it's a fully software emulated virtual machine, every instruction is interpreted and executed by software. With additional instrumentation, the system runs extremely slow. Hence it's difficult to make an comprehensive test since Windows apps may crash due to a slow GUI response.

An alternative way is to use data breakpoint. It's also called hardware breakpoint which traps the system when the CPU reads or writes the breakpoint~\cite{erickson2010effective}. The performance overhead is comparatively modest. But the number of data breakpoints is quit limited, for example, four data breakpoints per CPU in x86 architecture. So only several chosen locations can be monitored at a time.


%There is another proposal. First load a driver which sets up VM environment, puts OS run as a virtual machine, just like our project does. Then transfer into kernel mode, invalidate all user-mode data pages, for example, clear the “Present” flag for all top-level user-mode data page table entries. In such way that all kernel-mode access to 00000000-7fffffff yield a page fault exception. The hypervisor intercepts the page fault and set TF (Single Step) flag and restore the faulting page to let the OS successfully execute the faulting instruction. After that it intercepts DB exception and set the page back to invalidate.  But the drawback is also obvious, both the kernel and user mode will trigger the page faults exceptions, so in a multi-thread process, once one thread call into kernel mode, other user mode thread may be interrupted too often due to their data accessing.

We repurposed SMAP for vulnerability mitigation in this paper, now we want to further leverage this as a memory access monitor. Based on our test, we know that when a SMAP exception occurs, it's already too late to disable SAMP by setting the AC flag in EFLAGS register of the current thread. The same exception will keep coming back. Therefore, we need to add that page to kernel space just like what we do in the migitation. But we want to set the page back as soon as possible because we don't want to miss any further access on it. So we use the single-step trap to regain control. In the next instruction, we set the page back to it's original state, and record this access for later analysis. Now all the user memory accesses during a syscall can be monitored and the performance overhead is modest.

During the implementation, we found several bugs in win32k.sys module. For example, user data fetching without a "try \& catch", which may lead to a local DOS vulnerability if the attacker purposefully invalid the user pages during the syscall. We also found several double fetches with "read write" and "read read" patterns.

\textbf{IPI Mechanism  }Currently we reuse part of the functionality of Windows to flush TLB. Those internal functions are not exported and will change prototypes in further version. For further work, we plan to implement the IPI mechanism.

\subsection{Discussion: Solving Write Conflicts}

As mentioned in~\autoref{sec:design}, to solve the write conflicts, we choose to let the thread waiting inside the page fault handler. There could be other ways to solve this. At first we were considering the solution of a thread level copy-on-write(COW). First, we need a hypervisor that can dynamically switch page tables when the CPU runs on different threads. Even though there is no direct VM exit event that indicates thread switching, but since the OS needs to read/write some data structure when doing this, by monitoring pages that contains those data structures, thread switching can be monitored~\cite{pan2017digtool}.

When a thread writes a protected page, the current page table will be cloned, assigns it to the writing thread. And then duplicates the protected page with a new physical page, sets it as writable in PTE of the new page table. Therefore the thread can write to the page without affecting the user data that previously being referenced by the syscall.

When the syscall ends, it's time to merge the two pages and two set of page tables back. But it's hard to decide which page's content should remain. By bring up this discussion, We hope to find a more reliable solution. 


