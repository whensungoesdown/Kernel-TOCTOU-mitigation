%! TEX root = '../main.tex'

\section{Introduction}
\label{sec:ktoctou-introduction}


Time-of-check-to-time-of-use (TOCTOU) a.k.a race condition and double fetch is a long-standing issue in software security. As the name implied, it involves two references on the same variable or system state. The attacker usually passes the first security check with a benign value and then changes it to a malicious one before the second reference. This behavior could introduce faults into the system, with which the attacker tries to gain more control.

This paper focuses on kernel-level TOCTOU vulnerabilities and their mitigation. Modern operating systems such as Windows and Linux separate the kernel and user programs into two security domains,  where the kernel runs in the privileged domain, and the user programs run in the unprivileged domain. Due to the domain separation, the kernel serves the user programs on a service-client basis through system calls, and it inevitably gets parameters from the userspace. However, read the same user-mode variable repeatedly may lead to data inconsistency under a race condition between the kernel and user programs---namely, the user program invokes a system call with parameters and then change them rapidly to introduce faults into the kernel. Therefore, if a user program can inject faults into the kernel so that the kernel malfunctions or even run user-provided code, it is a so-called local privilege escalation attack. Such an attack nowadays is used to bypass sandbox protection of browsers or further get the administrator privilege after having a local user account.

Through studying the real-world vulnerability cases,  we find that kernel-level TOCTOU vulnerability widely exists in the operating systems, especially Microsoft Windows. Notably, a graphical subsystem kernel module tightly coupled with user-mode libraries freely access user-mode data structures, among which double fetches on the same variable is not unusual. In essence, the kernel repeatedly reads the same user-mode memory address within a short period, namely, within the same system call. 

To find the bugs with the typical memory-access pattern, we develop a fuzzing tool that leverages an Intel CPU feature, Supervisor Mode Access Prevention (SMAP), and combined with a run-time hypervisor to monitor the Windows kernel swiftly. SMAP is a feature, since the Intel Broadwell microarchitecture, that prevents the kernel from freely accessing userspace so that such access will raise an exception. It accurately serves the purpose of notifying us when the kernel access a user-mode address. For each system call, we pick out those user-mode addresses that the kernel reads twice, which are the candidates for further analysis. Following we contacted Microsoft for our findings.

Furthermore, we present \name, the first run-time protection for kernel-level TOCTOU vulnerabilities, to the best of our knowledge. It also leverages the same hardware feature SMAP and the hypervisor. Base on our observation on the vulnerability, to retain the virtual memory that the kernel fetched unwritable is the key to successful protection. Considering hardware capability and practical aspects, we propose the following idea. Whenever the kernel accesses a user-mode memory, \name protects the corresponding page by setting it as a kernel page until the current system call ends so that no other user threads can tamper with it. We also address the practical issue that benign read and write access to the data that resides on the protected page.


Due to the Windows system's complex nature and the fact that it did not adopt SMAP, when enabling this feature, the amount of exception is enormous, and the causes are various. It is difficult to handle such a multifactorial situation, if not impossible. To first solve the core issue without interference from other factors, we use the hypervisor to contain SMAP within one process. The hypervisor takes action on the process context switch event and makes SMAP active only when the specific process is actual runs on the CPU. Later, we also find that to prevent recurring SMAP from forming a deadlock during page table walking, isolating SMAP is crucial. Additionally, it makes \name more configurable, avoids unnecessary processes, thus improves performance. Therefore, we consider the light-weight hypervisor framework as one of the contributions of this paper. 

\textbf{Contributions.} To summarize, we make the following contributions in this paper:
\begin{itemize}[leftmargin=*]
    \item We identify kernel TOCTOU vulnerability using study cases, and demonstrated with practical exploits against them. 
    \item We present \name, a novel run-time mitigation framework leveraging hardware feature (SMAP). 
    \item We propose a configurable light-weight hypervisor to isolate system-wide CPU features.
    \item We develop a fuzzing tool for detecting kernel TOCTOU vulnerabilities.
    \item We have implemented \name and evaluated it with a number of benchmark programs with real-word vulnerabilities.
  
\end{itemize}


\textbf{Roadmap}
The rest of this paper is organized as the following. 
In ~\autoref{sec:ktoctou-background}, we provide necessary background related to the mechanism behind kernel TOCTOU vulnerabilities and SMAP. ~\autoref{sec:ktoctou-overview} describes the objectives, threat model and scope, challenges and architecture of \name. Next, we present how we perform run-time mitigation with SMAP and a light-weight hypervisor (~\autoref{sec:ktoctou-design}),  with implementation details ( ~\autoref{sec:ktoctou-implementation}), evaluation (~\autoref{sec:ktoctou-evaluation}), and tool() respectively.  In ~\autoref{sec:ktoctou-discussion},  we discuss an alternative to solve the writing conflicts and methods of fuzzing, followed by related work in ~\autoref{sec:ktoctou-relatedwork}, we discuss related works. Finally ~\autoref{sec:ktoctou-conclusion} concludes the paper.
