%! TEX root = 'main.tex'

\section{Introduction}

Time-of-check-to-time-of-use (TOCTOU) also known as "race condition" or "double fetch" is a long standing problem in software security. As implied by its name, it occurs because of data changes between the security check points and the data use. TOCTOU is a problem of data inconsistency and it exits in many systems nowadays while having different forms. In this paper, we focus on the one that happens in operating system kernel, so-called kernel TOCTOU, and usually leads to privilege escalation.

Modern operating systems such as Windows and Linux usually have two modes of operation, kernel mode and user mode. Operating system's kernel runs in kernel mode, and has complete access to all of the computer's hardware resources. Kernel provides most of the system's functionality including file system, network, scheduling, and displaying through system calls. The rest of the programs runs in user mode and is isolated from the kernel. They make system calls with parameters to get services via a client-server model. Those parameters could be constant number, pointers, and data structures which may also contain sub-level pointers.

There are cases, where user-mode variables as system call parameters being referenced directly by operating system. It is not protected by any system mechanism and those variables also can be modified by other threads at anytime. A good practice to handle parameters for kernel is to "capture" user variables first. Kernel should make its own copy of what it is about to use, and keep the copy instead of the original one through the entire system call execution. Otherwise, malicious applications are able to send in legit parameter to pass kernel's sanity check and later replace it with a malicious one.

To mitigate such attacks, we leverage Intel Supervisor Mode Access Prevention (SMAP) to monitor memory accesses. SMAP is a CPU feature that prevents operating system kernel from accessing user-mode memory directly. Any user memory reference will raise an exception that will be handled by our page fault handler. When a system call reads/writes a user variable, the page referenced will be protected by changing it to a kernel page. Therefore, no modification from user-mode will be allowed during the system call execution. It can also be set back to user page but with read-only attribute, so they are readable again by other threads of the same process. When the current system call ends, protected pages will be restored to their original attributes. 

Malicious shared data access pattern is the core cause for kernel TOCTOU. To ensure zero false positives, our solution should identify all legitimate data accesses accurately. For instance, a program thread may attempt writing to shared data, while it (or other data on the same memory page) is protected because of the active system call by another thread. To address that, our solution is to hold the write thread, waiting for the system call to end when the page is no longer protected. Once done, the page permissions are restored and the write thread is scheduled for execution and write access. 

The contributions of this paper are as follows:
\begin{itemize}
	\item 
    \item 
    \item 
\end{itemize}

We also implement a hypervisor which can confine a system wide feature such as SMAP to a specific process. We observe that not all the processes need to be monitored such as process that already run with administrator or system privilege. Because kernel TOCTOU vulnerabilities are mostly used to escalate privilege, only services that has interface exposed and alien process are the main suspects of such attack. With our hypervisor, process can be specified according to the system policy, it can greatly reduce system overhead.

%The hypervisor can further do more fine-grain isolation to thread level. It not only make a hardware feature more flexible, but also enrich hardware level resources. For example, Intel x86 processors support up to four hardware breakpoints/watchpoints using the special purpose DR0 to DR7 registers, but with our hypervisor framework, it can provide four breakpoints/watchpoints for each thread.  (should we mention that?)

This paper is organized as follows. 
