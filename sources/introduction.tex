%! TEX root = 'main.tex'

\section{Introduction}

Time-of-check-to-time-of-use (TOCTOU) also known as "race condition" or "double fetch" is a long standing problem in software security. It has more than three decades of history. As implied by its name, it occurs because of data changes between the security check points and the data use. TOCTOU is a problem of data inconsistency and it exits in many systems nowadays while having different forms. In this paper, we focus on the one that happens in operating system kernel, so-called kernel TOCTOU, and usually leads to privilege escalation.

Modern operating systems such as Windows and Linux usually have two modes of operation, kernel mode and user mode. Operating system's kernel runs in kernel mode, and has complete access to all of the computer's hardware resources. Kernel provides most of the system's functionality including file system, network, scheduling, and displaying through system calls. The rest of the programs runs in user mode and is isolated from the kernel. They make system calls with parameters to get services via a client-server model. Those parameters could be constant number, pointers, and data structures which may also contain sub-level pointers.

There are cases, where user-mode variables as system call parameters being referenced directly by operating system. It is not protected by any system mechanism and those variables also can be modified by other threads at anytime. A good practice to handle parameters for kernel is to "capture" user variables first. Kernel should make its own copy of what it is about to use, and keep the copy instead of the original one through the entire system call execution. Otherwise, malicious applications are able to send in legit parameter to pass kernel's sanity check and later replace it with a malicious one. And this still is what's going on in the modern operating system currently. It may caused by sub-level pointers that embedded in some data structure whose upper level pointer as one of the syscalls parameter is copied to the kernel stack automatically, or due to historical reasons, the operating system may even store and fetch data directly from user-mode space. One thing in common, the kernel trusts the user-mode part of data as unchangeable during the period of its operation, which is not true when in the circumstances of attacking. Moreover
, due to the nature of this attack which may only involves precise timing and memory overwriting, it's difficult to perform even a run-time checking, not to mention protection. Existing solutions being either too much of overhead or incomplete space coverage.

To mitigate such attacks, we leverage a hardware feature, Intel Supervisor Mode Access Prevention (SMAP) to monitor memory accesses. SMAP is a CPU feature that prevents operating system kernel from accessing user-mode memory directly. Any user memory reference will raise an exception that will be handled by our page fault handler hook. When a system call reads/writes a user variable, the page referenced will be protected by changing it to a kernel page. Therefore, no modification from user-mode will be allowed during the system call execution. Those pages could also be set back to user page with read-only attribute, hence they are readable by other user threads. After the current system call ends, protected pages will be restored to their original state.

We also propose an approach to solve conflicts when other user threads try to write to the protected page. This is common when multiple threads have some shared data or using the same heap pool. Normally it's a hard case because there is no practical way to protect a partial of a page due to the current x86 architecture. Instead of tracing each instructions as what single step trap does, we make the writing thread wait and check periodically whether the page is off protection. This operation is done within the context of the current exception that caused by SMAP, hence no more monitoring or tracing needed. This paper makes the following contributions.

%Malicious shared data access pattern is the core cause for kernel TOCTOU. To ensure zero false positives, our solution should identify all legitimate data accesses accurately. For instance, a program thread may attempt writing to shared data, while it (or other data on the same memory page) is protected because of the active system call by another thread. To address that, our solution is to hold the write thread, waiting for the system call to end when the page is no longer protected. Once done, the page permissions are restored and the write thread is scheduled for execution and write access. 

%The contributions of this paper are as follows:
\begin{itemize}[leftmargin=*]
    \item We investigated how kernel TOCTOU work with study cases.
    \item Proposing a novel run-time mitigation which leverage hardware feature(SMAP) to achieve modest performance overhead. 
    \item We evaluated it with real-word vulnerabilities and measured performance overhead.
    \item We made a tool that also leverage SMAP to find more kernel TOCTOU vulnerabilities.
\end{itemize}

%We also implement a hypervisor which can confine a system wide feature such as SMAP to a specific process. We observe that not all the processes need to be monitored such as process that already run with administrator or system privilege. Because kernel TOCTOU vulnerabilities are mostly used to escalate privilege, only services that has interface exposed and alien process are the main suspects of such attack. With our hypervisor, process can be specified according to the system policy, it can greatly reduce system overhead.

Since SMAP is a CPU feature, setting it will cause effect on all the processes in the system. Our platform is Windows OS which didn't regulate it's kernel to compliance. So debugging a system feature concurrently on all the processes is inconvenient. To make it even possible, we implemented a light-weight hypervisor which can confine the system wide feature SMAP to one or more specific processes. We also argue that not all processes in the system need to be protected equally. For example, the ones that already run with administrator or system privilege are needless to monitor, because kernel TOCTOU vulnerabilities are mostly used to escalate privilege, and only those who has interface exposed to users or alien processes are the main candidates. With the hyervisor, we can choose processes according to the security policy meanwhile greatly lower the performance overhead for the whole system. 

We made this system-feather-isolating hypervisor framework easily adoptable, which is also can be considered as a contribution of this paper.

%The hypervisor can further do more fine-grain isolation to thread level. It not only make a hardware feature more flexible, but also enrich hardware level resources. For example, Intel x86 processors support up to four hardware breakpoints/watchpoints using the special purpose DR0 to DR7 registers, but with our hypervisor framework, it can provide four breakpoints/watchpoints for each thread.  (should we mention that?)

This paper is organized as follows. 
