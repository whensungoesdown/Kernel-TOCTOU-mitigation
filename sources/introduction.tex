%! TEX root = '../main.tex'

\section{Introduction}
\label{sec:introduction}

Time-of-check-to-time-of-use (TOCTOU) is also known as ``race condition'' or ``double fetch''. It is a long-standing problem in the software security domain. As its name implied, it involves at least two references (on variables). The first reference is usually a security check.  If they passed, for example, the variable's value is not too large,  then assuming it is safe to use it, copying buffer. The variables are in a less privileged security domain. During the time gap,  an attacker could change the variable's value to a much larger one. That may introduce a buffer overflow. TOCTOU is a problem of data inconsistency and it exists in many systems nowadays and it also has many forms. In this paper, we focus on the one that happens in the operating system kernel. This type of attack not only disturbs the system status but also can lead to a serious breach.

Modern operating systems such as Windows and Linux have two modes. OS kernel runs in the most privileged mode (kernel-mode). It can access all the computer's hardware resources. It connects them to the application software through system calls. The applications run in user mode which is the least privileged mode (user-mode). It separates from the kernel. To access privileged resources, the application makes system calls with parameters. In a well-designed OS, this is a formal method for kernel and application exchanging data.


The kernel should make a copy of what is going to use from user space and keep it for the whole lifespan of the system call.  Commercial operating systems each have their own way. For example, the Windows kernel will first ``capture'' user variables. Linux has \texttt{copy\_to\_user()} and \texttt{copy\_from\_user()} API for kernel and drivers. But due to historical reasons, OS may not always follow that rule or make mistakes.

There are cases where the kernel read or store user-mode variables. This is possible as long as the user page is valid while accessing. But it is also vulnerable. Because a malicious user can use another thread to access those variables at the same time. 

Plain memory access is common, even it is from kernel to user space. In essence, it is a bad programming practice rather than a fault. Hence, existing solutions are either high-overhead or low-coverage.

To mitigate as a run-time solution, must find such kernel behaviors in a low-cost manner. We learned that Intel's CPU series has an interesting feature. That is Supervisor Mode Access Prevention (SMAP). When enabled, it prevents the kernel from accessing user space. Such violations will raise exceptions. %We call it the SMAP exception for the rest of the paper.

We take control of the page fault handler.  The system should halt when it sees a SMAP exception.  Instead, we handle it and keep the system going. To protect the page, we find its corresponding page table entry (PTE) and clear the USER/SUPERVISOR bit. After this, the user page becomes a kernel page. User threads are no longer able to access it. Also, this is the only way to continue from a SMAP exception.  This page will remain in the kernel until the current system call ends.

There are still legit user-mode accesses on this user page. If it is a read, set the page READONLY and move it back to the user space. 
For the write access, we stale the user thread until the current system call ends.

%We also implement a hypervisor which can confine a system wide feature such as SMAP to a specific process. We observe that not all the processes need to be monitored such as process that already run with administrator or system privilege. Because kernel TOCTOU vulnerabilities are mostly used to escalate privilege, only services that has interface exposed and alien process are the main suspects of such attack. With our hypervisor, process can be specified according to the system policy, it can greatly reduce system overhead.

SMAP is a system-wide CPU feature. It is active when the SMAP bit in the CR4 control register is set.  Once enabled, it affects every process in the system. The mitigation is to protect the kernel against the malicious user process. In most cases, the attacker uses kernel TOCTOU vulnerability to further escalate privilege. Hence, many trusted processes don't need protection. Processes that are already running at a high privilege also don't need it. 
\hb{totally not able to understand what you are trying to say in above paragraphs.}

To contain SMAP within each process, \hb{why SMAP need to be contained in each process, then you can tell how briefly} we develop a light-weight hypervisor. It monitors the process scheduling. Each process has its own set of control registers, established by the hypervisor. When scheduling a new process, it brings the new control register values to the hardware. Hence, the SMAP bit is set only when the current process matches the policy. This way the mitigation is more configurable and it introduces less overhead \hb{this maybe the first sentence in the beginning}.

The light-weight hypervisor itself is easy to configure for other applications. It is also a contribution of this paper.\hb{why throw this sentence here? what do you want to express here??}



\textbf{Contributions.} To summarize, we make the following contributions in this paper:
\begin{itemize}[leftmargin=*]
    \item We identify kernel TOCTOU vulnerability using study cases, and demonstrated with practical exploits against them. 
    \item We present \name, a novel run-time mitigation framework leveraging hardware feature (SMAP). 
    \item We propose a configurable light-weight hypervisor to isolate system-wide CPU features.
    \item We develop a fuzzing tool for detecting kernel TOCTOU vulnerabilities.
    \item We have implemented \name and evaluated it with a number of benchmark programs with real-word vulnerabilities.
  
\end{itemize}


\textbf{Roadmap}
The rest of this paper is organized as the following. 
In ~\autoref{sec:background}, we provide necessary background related to the mechanism behind kernel TOCTOU vulnerabilities and SMAP. ~\autoref{} describes the objectives, threat model and scope, challenges and architecture of \name. Next, we present how we perform run-time mitigation with SMAP and a light-weight hypervisor (~\autoref{}),  with implementation details ( ~\autoref{sec:implementation}), evaluation (~\autoref{sec:evaluation}), and tool() respectively.  In ~\autoref{sec:discussion},  we discuss an alternative to solve the writing conflicts and methods of fuzzing, followed by related work in ~\autoref{sec:relatedwork}, we discuss related works. Finally ~\autoref{sec:conclusion} concludes the paper.
