%! TEX root = '../main.tex'

\section{Introduction}
\label{sec:introduction}

Time-of-check-to-time-of-use (TOCTOU) is also known as "race condition" or "double fetch". It is a long-standing problem in the software security domain. As its name implied, it involves at least two references (on variables). The first reference is usually a security check.  If they passed, for example, the variable's value is not too large,  then assuming it is safe to use it, copying buffer. The variables are in a less privileged security domain. During the time gap,  an attacker could change the variable's value to a much larger one. That may introduce a buffer overflow. TOCTOU is a problem of data inconsistency and it exits in many systems nowadays and it also has many forms. In this paper, we focus on the one that happens in the operating system kernel. This type of attack not only disturbs the system status but also can lead to a serious breach.

Modern operating systems such as Windows and Linux have two modes. OS kernel runs in the most privileged mode (kernel-mode). It can access all the computer's hardware resources. It connects them to the application software through system calls. The applications run in user mode which is the least privileged mode (user-mode). It separates from the kernel. To access privileged resources, the application makes system calls with parameters. In a well-designed OS, this is a formal method for kernel and application exchanging data.


The kernel should make a copy of what is going to use from user space and keep it for the whole lifespan of the system call.  Commercial operating systems each have their own way. For example, the Windows kernel will first "capture" user variables. Linux has copy\_to\_user() and copy\_from\_user() API for kernel and drivers. But due to historical reasons, OS may not always follow that rule or make mistakes.

There are cases where the kernel read or store user-mode variables. This is possible as long as the user page is valid while accessing. But it is also vulnerable. Because a malicious user can use another thread to access those variables at the same time. 

Plain memory access is common, even it is from kernel to user space. In essence, it is a bad programming practice rather than a fault. Hence, existing solutions are either high-overhead or low-coverage.

To mitigate as a run-time solution, must find such kernel behaviors in a low-cost manner. We learned that Intel's CPU series has an interesting feature. That is Supervisor Mode Access Prevention (SMAP). When enabled, it prevents the kernel from accessing user space. Such violations will raise exceptions. We call it the SMAP exception for the rest of the paper.

We take control of the page fault handler.  The system should halt when it sees a SMAP exception.  Instead, we handle it and keep the system going. To protect the page, we find its corresponding page table entry (PTE) and clear the USER/SUPERVISOR bit. After this, the user page becomes a kernel page. User threads are no longer able to access it. Also, this is the only way to continue from a SMAP exception.  This page will remain in the kernel until the current system call ends.

There are still legit user-mode accesses on this user page. If it is a read, set the page READONLY and move it back to the user space. 
For the write access, we stale the user thread until the current system call ends.

%We also implement a hypervisor which can confine a system wide feature such as SMAP to a specific process. We observe that not all the processes need to be monitored such as process that already run with administrator or system privilege. Because kernel TOCTOU vulnerabilities are mostly used to escalate privilege, only services that has interface exposed and alien process are the main suspects of such attack. With our hypervisor, process can be specified according to the system policy, it can greatly reduce system overhead.

SMAP is a system-wide CPU feature. It is active when the SMAP bit in the CR4 control register is set.  Once enabled, it affects every process in the system. The mitigation is to protect the kernel against the malicious user process. In most cases, the attacker uses kernel TOCTOU vulnerability to further escalate privilege. Hence, many trusted processes don't need protection. Processes that are already running at a high privilege also don't need it. 

To contain SMAP within each process, we develop a light-weight hypervisor. It monitors the process scheduling. Each process has its own set of control registers, established by the hypervisor. When scheduling a new process, it brings the new control register values to the hardware. Hence, the SMAP bit is set only when the current process matches the policy. This way the mitigation is more configurable and it introduces less overhead.

The light-weight hypervisor itself is easy to configure for other applications. It is also a contribution of this paper.



The contributions of this paper:
\begin{itemize}[leftmargin=*]
    \item We investigate on kernel TOCTOU vulnerability using study cases.
    \item A novel run-time mitigation leveraging hardware feature (SMAP). 
    \item Evaluation with real-word vulnerabilities.
    \item A configurable light-weight hypervisor to isolate system-wide CPU features.
    \item A fuzzing tool for kernel TOCTOU vulnerabilities.
\end{itemize}



This paper is organized as the following. 
This work is structured as follows. In ~\autoref{sec:background}, we describe the mechanism behind kernel TOCTOU vulnerabilities. Give background information about this hardware feature SMAP. In ~\autoref{sec:design}, we describe our framework for run-time mitigation. How the light-weight hypervisor contains the SMAP feature on a particular process. In ~\autoref{sec:implementation}, we document some implementation details. In ~\autoref{sec:evaluation}, we test our mitigation with real-world vulnerabilities.  In ~\autoref{sec:discussion},  we discuss an alternative to solve the writing conflicts and methods of fuzzing. In ~\autoref{sec:relatedwork}, we discuss related works and conclude with ~\autoref{sec:conclusion}.
